{
  "secrets_management": {
    "prevention": [
      { "order": 1, "control": "Prohibit secrets in repository content" },
      { "order": 2, "control": "Store long-lived secrets only in platform secure stores" },
      { "order": 3, "control": "Inject secrets only at runtime to required process scopes" },
      { "order": 4, "control": "Mandatory redaction on all outbound text channels" },
      { "order": 5, "control": "Scan persistence/release surfaces before write or publish" }
    ],
    "classes": [
      {
        "id": "SECRET-CLASS-01",
        "name": "Runtime User Credentials",
        "custody": "Host OS secure storage + runtime-mediated retrieval",
        "storage": {
          "nixos_prod": "sops-nix with age encryption (encrypted at rest, decrypted to tmpfs at runtime via systemd activation)",
          "macos_dev": "macOS Keychain",
          "note": "sops-nix satisfies the systemd-creds runtime injection model: secrets are encrypted in repo, decrypted by sops-nix activation service to owner-restricted tmpfs paths, and referenced via EnvironmentFile in systemd units. No plaintext secrets exist on disk outside the tmpfs lifecycle."
        },
        "forbidden": ["repo plaintext", "app config plaintext", "uncontrolled local files"]
      },
      {
        "id": "SECRET-CLASS-02",
        "name": "CI/CD Secrets",
        "custody": "Controlled build environment only",
        "storage": "GitHub Actions secrets + runtime-injected workflow env",
        "forbidden": ["developer machines", "repo source", "build logs"]
      },
      {
        "id": "SECRET-CLASS-03",
        "name": "Release Signing Private Keys",
        "custody": "Eliminated from long-lived secret inventory",
        "storage": "Sigstore keyless signing model",
        "forbidden": ["repo key files", "CI key vault artifacts", "operator key escrow"]
      }
    ],
    "in_memory": [
      "Crypto keys in Rustler NIF memory with Rust Zeroize on drop",
      "Elixir receives opaque references only",
      "Elixir-side secrets overwritten with crypto.strong_rand_bytes before release",
      "Avoid disclosure through debug formatting and cloning paths"
    ],
    "distribution": [
      "Inject via Elixir runtime config backed by sops-nix (NixOS) or env vars (dev)",
      "Erlang distribution protocol disabled in production",
      "Never pass secrets via CLI arguments (visible in process listings)",
      "Limit propagation by process boundary and scoped injection"
    ],
    "credential_handling": {
      "mounted_credentials": [
        "Claude auth tokens (filtered from .env, read-only)"
      ],
      "not_mounted": [
        "WhatsApp session store/auth",
        "Mount allowlist (~/.config/guardian-core/mount-allowlist.json)",
        "Any credentials matching blocked patterns"
      ],
      "env_allowlist": [
        "CLAUDE_CODE_OAUTH_TOKEN",
        "ANTHROPIC_API_KEY"
      ],
      "note": "Agent execution environment can access mounted credentials if present; prefer host-mediated auth when available."
    },
    "logging": {
      "redactor": "SecretRedactor",
      "patterns": ["*_KEY", "*_TOKEN", "*_SECRET", "*_PASSWORD", "cloud/provider prefixes"],
      "surfaces": ["runtime logs", "API response bodies", "errors", "textual channels"],
      "rule": "Build artifacts and logs are durable exfiltration channels"
    },
    "scanning": {
      "targets": ["file writes", "build outputs", "release artifacts"],
      "policy": "Mandatory defense-in-depth, not optional linting",
      "pairing": "Combine with release signing and provenance"
    },
    "ci_cd": [
      "Inject CI secrets only at job runtime to requiring jobs",
      "Avoid command options that echo tokens; use silent modes",
      "Never embed CI secrets in source, generated files, or artifact metadata"
    ],
    "local_testing": {
      "method": ".env files gitignored and loaded through controlled mechanisms",
      "rule": "Prevent test convenience from creating shadow secret stores"
    },
    "rotation": {
      "default": "90d",
      "on_compromise": "immediate",
      "rule": "Coordinate rotation with incident-response containment timelines"
    },
    "keyless_signing": {
      "model": "Sigstore keyless",
      "mechanism": "Workload identity (OIDC) + short-lived certs + transparency logs",
      "rule": "Distinct from runtime authority authentication semantics"
    },
    "incident_seq": [
      { "order": 1, "action": "Revoke exposed credentials immediately" },
      { "order": 2, "action": "Rotate related credentials to reduce dwell time" },
      { "order": 3, "action": "Audit for misuse and unauthorized access" },
      { "order": 4, "action": "Remediate repo and artifact history if applicable" },
      { "order": 5, "action": "Document root cause, timeline, and preventive actions" }
    ],
    "invariants": [
      "No plaintext repository secret storage",
      "No secret leakage in logs, errors, or artifacts",
      "Platform-backed runtime storage and controlled CI custody",
      "Prescriptive incident handling for any suspected leak",
      "Automatable controls prioritized over advisory guidance"
    ]
  }
}
